/* DO NOT EDIT THIS FILE.
 * This file is automatically generated from cbusdefs.csv
 */

namespace merg.cbus
{
    // 
    // Copyright (C) Pete Brownlow 2011-2022   software@upsys.co.uk
    // Originally derived from opcodes.h (c) Andrew Crosland.
    // CSV version by Ian Hogg inspired by David W Radcliffe
    // 
    // Ver 8w 
    // 
    //   This work is licensed under the:
    //       Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.
    //   To view a copy of this license, visit:
    //       http://creativecommons.org/licenses/by-nc-sa/4.0/
    //   or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.
    // 
    //   License summary:
    //     You are free to:
    //       Share, copy and redistribute the material in any medium or format
    //       Adapt, remix, transform, and build upon the material
    // 
    //     The licensor cannot revoke these freedoms as long as you follow the license terms.
    // 
    //     Attribution : You must give appropriate credit, provide a link to the license,
    //                    and indicate if changes were made. You may do so in any reasonable manner,
    //                    but not in any way that suggests the licensor endorses you or your use.
    // 
    //     NonCommercial : You may not use the material for commercial purposes. **(see note below)
    // 
    //     ShareAlike : If you remix, transform, or build upon the material, you must distribute
    //                   your contributions under the same license as the original.
    // 
    //     No additional restrictions : You may not apply legal terms or technological measures that
    //                                   legally restrict others from doing anything the license permits.
    // 
    //    ** For commercial use, please contact the original copyright holder(s) to agree licensing terms
    // 
    //     This software is distributed in the hope that it will be useful, but WITHOUT ANY
    //     WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE
    // 
    // Version history:
    // Pete Brownlow,6/4/11,Original from spec version 7e
    // Roger Healey,6/4/11,Add OPC_CMDERR response codes
    // Pete Brownlow,7/6/11,Updated to spec ver 7f and add new module ids
    // Pete Brownlow,4/7/11,Updated to spec ver 7g
    // Pete Brownlow,14/8/11,Updated to spec ver 7h
    // Pete Brownlow,18/2/12,Updated to spec ver 8a, Rocrail and animated modeller module types added
    // Pete Brownlow,10/4/12,Updated to spec ver 8b, extended parameter bytes
    // Pete Brownlow,17/4/12,Updated parameter block definitions, added processor type definitions.
    // Roger Healey,13/7/12,Add CANTOTI
    // Pete Brownlow,15/9/12,Updated to spec ver 8c, added 0x5D ENUM and 0x75 CANID
    // Pete Brownlow,4/1/13,Ver 8d New module types, added 0x5E  NNRST
    // Roger Healey,15/2/13,Now at version d. Added new Module Ids (as per ModuleIds Issue 9) and
    //          Align Processor Ids with constants.inc
    //          Added .(fullstop) before each processor Id > 9
    //          Added OPC_NNRST
    // Roger Healey,27/4/13,Added CANSIG8 and CANSIG64
    // Roger Healey,6/8/13,Added CANCOND8C
    // Roger Healey,22/1/14,Added CANPAN, CANACE3C, CANPanel and CANMIO
    // Pete Brownlow,22/1/14,Ver 8g New module types, OPC_NNRST & OPC_NNRSM, catch up with .inc file
    //          Added parameter definitions for manufacturer's CPU id
    //          Added extern C so can be included by c++ code
    //          Fixed CANGC1e type definition
    // Phil Wheeler,1/2/14,Corrected some typos. Added PRM_BETA, dotted some more decimal numbers
    // Phil Wheeler,9/3/14,Corrected CANSIG MTYP definitions
    // Pete Brownlow,19/4/14,Ver 8h Added module type defs for CANTOTIMIO, CANACE8MIO, CANBIP, CANSOL
    // Pete Brownlow,06/7/15,Ver 8j Add new module types as per modules definitions v17 : CANCDU, CANACC4CDU, CANWiBase, WiCAB, CANWiFi, CANFTT
    //          Add new opcode ALOC, added CPU manufacturer code CPUM_ATMEL
    // Mike Bolton,2/3/16,Ver 8k    Add module type CANRFID8
    // Pete Brownlow,2/7/16,Ver 8m Add new module types CANHNDST, CANTCHNDST, CANmchRFID and CANPiWi
    //          Add processor codes for ARM chips used in Raspberry Pi's
    // Pete Brownlow,16/2/17,Ver 8n Add module ids to bring it up to module ids document ver 25
    // Pete Brownlow,29/7/17,Ver 8p Add new module ids and new cab signalling opcode
    // Pete Brownlow,09/1/18,Ver 8q Add new parameter flag for module can consume its own events
    // Ian Hogg,11/9/18,Ver 8r Added CANACE16CMIO, CANPiNODE, CANDISP, CANCOMPUTE
    // Richard Crawshaw,29/02/2020,Fixed order of columns in CbusCabSigAspect2.
    // Pete Brownlow,01/09/20,Ver 8s for additional module ids defined in the ModuleIds file ver 33.
    //                        Updated descriptive comments for some module types
    //                        Updated CABDAT opcode to match RFC0004
    // Pete Brownlow,06/09/20,Ver 8t Added module type for CANRCOM. Fixed: Opcode for CABDAT, names for CANRC522 and CANMAG
    // Pete Brownlow,13/10/20,Ver 8u Added module types 67 to 74 including some Arduino projects
    //                               Added SPROG manufacturer code 44 and new SPROG CBUS module types
    //                               Additional error code for overload - now removed as not required after all
    //                               New bus type USB for modules with only USB and no CAN
    // Pete Brownlow,19/02/21,Ver 8u Added manufacturer code 13 for new development - who don't have a manufacturer id yet
    //                               Added proccessor identification codes for 18F25k83, 18F26k83 and 18F14K22.
    // Andrew Crosland,21/09/2021,Ver 8t Added PICs P18F14K22 P18F26K83 P18F27Q84 P18F47Q84 and P18F27Q83
    // Andrew Crosland,19/01/2022,Ver 8t, Added OPC_VCVS, Verify CV service mode - used for CV read hints, update SPROG modules types (PR#13)
    // Duncan Greenwood,07/10/2021,Ver 8t Added OPC_DTXC opcode (0xE9) for CBUS long messages - RFC 0005
    // Richard Crawshaw,11/10/2021,Ver 8t Fixed trailing comma in CbusCabSigAspect0
    // Pete Brownlow,28/07/2022,Ver 8v Resolve and merge changes in 8u branch with changes subsequently applied to master, now ver 8v in new branch,
    //   							Add requested module type ids 75 to 78
    //                               Resolve changes from PR #13,  move proposed and/or agreed opcodes not yet in the published spec to below the others
    // Pete Brownlow,5/08/2022, Ver 8w  Add module type 79 for CANBUFFER
    // Pete Brownlow,5/01/2023, Ver 8w  Add module type 80 for CANPMSense
    // Ian Hogg,14/08/2023, Ver 8x  Add manufacturer code for VLCB. This is a way to allocate a block of module Id to VLCB even though VLCB group is not a manufacturer per se. The VLCB module IDs will be defined in the VLCB repo
    // Pete Brownlow,2/11/23, Ver 8x  Add module id for CANLEVER (Tim Coombs)
    // Pete Brownlow,3/11/23, Ver 8x  Update SPROG module type ids (Andrew Crosland)

    public static class CbusDefs
    {
        /// <summary>
        /// ARM Processor type codes (identifies to FCU for bootload compatibility)
        /// </summary>
        public static class CbusArmProcessors
        {

            /// <summary>
            /// As used in Raspberry Pi
            /// </summary>
			public const int ARM1176JZF_S = 1;

            /// <summary>
            /// As Used in Raspberry Pi 2
            /// </summary>
			public const int ARMCortex_A7 = 2;

            /// <summary>
            /// As used in Raspberry Pi 3
            /// </summary>
			public const int ARMCortex_A53 = 3;
        }
        /// <summary>
        /// BUS type that module is connected to
        /// </summary>
        public static class CbusBusTypes
        {

			public const int PB_CAN = 1;

			public const int PB_ETH = 2;

			public const int PB_MIWI = 3;

			public const int PB_USB = 4;
        }
        /// <summary>
        /// Sub opcodes for OPC_CABDAT
        /// </summary>
        public static class CbusCabSigAspect0
        {

			public const int CDAT_CABSIG = 1;
        }
        /// <summary>
        /// Aspect codes for CDAT_CABSIG
        /// First aspect byte
        /// </summary>
        public static class CbusCabSigAspect1
        {

			public const int SASP_DANGER = 0;

			public const int SASP_CAUTION = 1;

			public const int SASP_PRELIM_CAUTION = 2;

			public const int SASP_PROCEED = 3;

            /// <summary>
            /// Set bit 2 for call-on - main aspect will usually be at danger
            /// </summary>
			public const int SASP_CALLON = 4;

            /// <summary>
            /// Set bit 3 to 0 for upper nibble is feather lcoation, set 1 for upper nibble is theatre code
            /// </summary>
			public const int SASP_THEATRE = 8;
        }
        /// <summary>
        /// Aspect codes for CDAT_CABSIG
        /// Second Aspect byte
        /// Remaining bits in second aspect byte yet to be defined - can be used for other signalling systems
        /// </summary>
        public static class CbusCabSigAspect2
        {

            /// <summary>
            /// Set bit 0 to indicate lit
            /// </summary>
			public const int SASP_LIT = 0;

            /// <summary>
            /// Set bit 1 for lunar indication
            /// </summary>
			public const int SASP_LUNAR = 1;
        }
        /// <summary>
        /// Error codes for OPC_CMDERR
        /// Additional error codes proposed and/or agreed but not yet in the current published specification
        /// </summary>
        public static class CbusCmdErrs
        {

			public const int CMDERR_INV_CMD = 1;

			public const int CMDERR_NOT_LRN = 2;

			public const int CMDERR_NOT_SETUP = 3;

			public const int CMDERR_TOO_MANY_EVENTS = 4;

			public const int CMDERR_NO_EV = 5;

			public const int CMDERR_INV_EV_IDX = 6;

			public const int CMDERR_INVALID_EVENT = 7;

            /// <summary>
            /// now reserved
            /// </summary>
			public const int CMDERR_INV_EN_IDX = 8;

			public const int CMDERR_INV_PARAM_IDX = 9;

			public const int CMDERR_INV_NV_IDX = 10;

			public const int CMDERR_INV_EV_VALUE = 11;

			public const int CMDERR_INV_NV_VALUE = 12;

            /// <summary>
            /// Sent when module in learn mode sees NNLRN for different module (also exits learn mode) 
            /// </summary>
			public const int CMDERR_LRN_OTHER = 13;
        }
        /// <summary>
        /// Error codes for OPC_ERR
        /// </summary>
        public static class CbusErrs
        {

			public const int ERR_LOCO_STACK_FULL = 1;

			public const int ERR_LOCO_ADDR_TAKEN = 2;

			public const int ERR_SESSION_NOT_PRESENT = 3;

			public const int ERR_CONSIST_EMPTY = 4;

			public const int ERR_LOCO_NOT_FOUND = 5;

			public const int ERR_CMD_RX_BUF_OFLOW = 6;

			public const int ERR_INVALID_REQUEST = 7;

			public const int ERR_SESSION_CANCELLED = 8;
        }
        /// <summary>
        /// CBUS Manufacturer definitions
        /// Where the manufacturer already has an NMRA code, this is used
        /// </summary>
        public static class CbusManufacturer
        {

            /// <summary>
            /// For new manufacturer development - who don't have a manufacturer id yet
            /// </summary>
			public const int MANU_DEV = 13;

            /// <summary>
            /// https://www.merg.co.uk
            /// </summary>
			public const int MANU_MERG = 165;

            /// <summary>
            /// https://www.sprog-dcc.co.uk/
            /// </summary>
			public const int MANU_SPROG = 44;

            /// <summary>
            /// http://www.rocrail.net
            /// </summary>
			public const int MANU_ROCRAIL = 70;

            /// <summary>
            /// http://animatedmodeler.com  (Spectrum Engineering)
            /// </summary>
			public const int MANU_SPECTRUM = 80;

            /// <summary>
            /// VLCB range of modules
            /// </summary>
			public const int MANU_VLCB = 250;

            /// <summary>
            /// Konrad Orlowski
            /// </summary>
			public const int MANU_SYSPIXIE = 249;

            /// <summary>
            /// http://rmeuk.com  (Railway Modelling Experts Limited)
            /// </summary>
			public const int MANU_RME = 248;
        }
        /// <summary>
        /// MODULE TYPES
        /// Please note that the existence of a module type id does not necessarily mean that firmware has been implemented
        /// MERG Module types
        /// At the time of writing the list of defined MERG module types is maintained by Pete Brownlow software@upsys.co.uk
        /// Please liaise with Pete before adding new module types, 
        /// and/or create your own GitHub branch, add your proposed new module type(s) and then create a Pull Request
        /// </summary>
        public static class CbusMergModuleTypes
        {

            /// <summary>
            /// default for SLiM nodes
            /// </summary>
			public const int MTYP_SLIM = 0;

            /// <summary>
            /// Solenoid point driver
            /// </summary>
			public const int MTYP_CANACC4 = 1;

            /// <summary>
            /// Motorised point driver
            /// </summary>
			public const int MTYP_CANACC5 = 2;

            /// <summary>
            /// 8 digital outputs
            /// </summary>
			public const int MTYP_CANACC8 = 3;

            /// <summary>
            /// Control panel switch/button encoder
            /// </summary>
			public const int MTYP_CANACE3 = 4;

            /// <summary>
            /// 8 digital inputs
            /// </summary>
			public const int MTYP_CANACE8C = 5;

            /// <summary>
            /// 64 led driver
            /// </summary>
			public const int MTYP_CANLED = 6;

            /// <summary>
            /// 64 led driver (multi leds per event)
            /// </summary>
			public const int MTYP_CANLED64 = 7;

            /// <summary>
            /// 12v version of CANACC4
            /// </summary>
			public const int MTYP_CANACC4_2 = 8;

            /// <summary>
            /// CANCAB hand throttle
            /// </summary>
			public const int MTYP_CANCAB = 9;

            /// <summary>
            /// CANCMD command station
            /// </summary>
			public const int MTYP_CANCMD = 10;

            /// <summary>
            /// 8 servo driver (on canacc8 or similar hardware)
            /// </summary>
			public const int MTYP_CANSERVO = 11;

            /// <summary>
            /// BC1a command station
            /// </summary>
			public const int MTYP_CANBC = 12;

            /// <summary>
            /// RPI and RFID interface
            /// </summary>
			public const int MTYP_CANRPI = 13;

            /// <summary>
            /// Turntable controller (turntable end)
            /// </summary>
			public const int MTYP_CANTTCA = 14;

            /// <summary>
            /// Turntable controller (control panel end)
            /// </summary>
			public const int MTYP_CANTTCB = 15;

            /// <summary>
            /// Handset controller for old BC1a type handsets
            /// </summary>
			public const int MTYP_CANHS = 16;

            /// <summary>
            /// Track occupancy detector
            /// </summary>
			public const int MTYP_CANTOTI = 17;

            /// <summary>
            /// 8 inputs 8 outputs
            /// </summary>
			public const int MTYP_CAN8I8O = 18;

            /// <summary>
            /// Canservo with servo position feedback
            /// </summary>
			public const int MTYP_CANSERVO8C = 19;

            /// <summary>
            /// RFID input
            /// </summary>
			public const int MTYP_CANRFID = 20;

			public const int MTYP_CANTC4 = 21;

            /// <summary>
            /// 16 inputs
            /// </summary>
			public const int MTYP_CANACE16C = 22;

            /// <summary>
            /// 8 way I/O
            /// </summary>
			public const int MTYP_CANIO8 = 23;

            /// <summary>
            /// ??
            /// </summary>
			public const int MTYP_CANSNDX = 24;

            /// <summary>
            /// Ethernet interface
            /// </summary>
			public const int MTYP_CANEther = 25;

            /// <summary>
            /// Multiple aspect signalling for CANLED module
            /// </summary>
			public const int MTYP_CANSIG64 = 26;

            /// <summary>
            /// Multiple aspect signalling for CANACC8 module
            /// </summary>
			public const int MTYP_CANSIG8 = 27;

            /// <summary>
            /// Conditional event generation
            /// </summary>
			public const int MTYP_CANCOND8C = 28;

            /// <summary>
            /// Control panel 32/32
            /// </summary>
			public const int MTYP_CANPAN = 29;

            /// <summary>
            /// Newer version of CANACE3 firmware
            /// </summary>
			public const int MTYP_CANACE3C = 30;

            /// <summary>
            /// Control panel 64/64
            /// </summary>
			public const int MTYP_CANPanel = 31;

            /// <summary>
            /// Multiple I/O – Universal CANMIO firmware
            /// </summary>
			public const int MTYP_CANMIO = 32;

            /// <summary>
            /// Multiple IO module 16 inputs emulating CANACE8C on CANMIO hardware
            /// </summary>
			public const int MTYP_CANACE8MIO = 33;

            /// <summary>
            /// Solenoid driver module
            /// </summary>
			public const int MTYP_CANSOL = 34;

            /// <summary>
            /// Universal CANBIP firmware - Bipolar IO module with additional 8 I/O pins (CANMIO family)
            /// </summary>
			public const int MTYP_CANBIP = 35;

            /// <summary>
            /// Solenoid driver module with additional 6 I/O pins (CANMIO family)
            /// </summary>
			public const int MTYP_CANCDU = 36;

            /// <summary>
            /// CANACC4 firmware ported to CANCDU
            /// </summary>
			public const int MTYP_CANACC4CDU = 37;

            /// <summary>
            /// CAN to MiWi base station
            /// </summary>
			public const int MTYP_CANWiBase = 38;

            /// <summary>
            /// Wireless cab using MiWi protocol
            /// </summary>
			public const int MTYP_WiCAB = 39;

            /// <summary>
            /// CAN to WiFi connection with Withrottle to CBUS protocol conversion
            /// </summary>
			public const int MTYP_CANWiFi = 40;

            /// <summary>
            /// Turntable controller configured using FLiM
            /// </summary>
			public const int MTYP_CANFTT = 41;

            /// <summary>
            /// Handset (alternative to CANCAB)
            /// </summary>
			public const int MTYP_CANHNDST = 42;

            /// <summary>
            /// Touchscreen handset
            /// </summary>
			public const int MTYP_CANTCHNDST = 43;

            /// <summary>
            /// multi-channel RFID reader
            /// </summary>
			public const int MTYP_CANRFID8 = 44;

            /// <summary>
            /// either a 2ch or 8ch RFID reader
            /// </summary>
			public const int MTYP_CANmchRFID = 45;

            /// <summary>
            /// a Raspberry Pi based module for WiFi
            /// </summary>
			public const int MTYP_CANPiWi = 46;

            /// <summary>
            /// DC train controller
            /// </summary>
			public const int MTYP_CAN4DC = 47;

            /// <summary>
            /// Nelevator controller
            /// </summary>
			public const int MTYP_CANELEV = 48;

            /// <summary>
            /// 128 switch inputs
            /// </summary>
			public const int MTYP_CANSCAN = 49;

            /// <summary>
            /// 16MHz 25k80 version of CANSERVO8c on CANMIO hardware
            /// </summary>
			public const int MTYP_CANMIO_SVO = 50;

            /// <summary>
            /// 16MHz 25k80 version of CANACE8MIO on CANMIO hardware
            /// </summary>
			public const int MTYP_CANMIO_INP = 51;

            /// <summary>
            /// 16MHz 25k80 version of CANACC8 on CANMIO hardware
            /// </summary>
			public const int MTYP_CANMIO_OUT = 52;

            /// <summary>
            /// 16MHz 25k80 version of CANACC5 on CANBIP hardware
            /// </summary>
			public const int MTYP_CANBIP_OUT = 53;

            /// <summary>
            /// DCC stop generator
            /// </summary>
			public const int MTYP_CANASTOP = 54;

            /// <summary>
            /// CANCMD with on board 3A booster
            /// </summary>
			public const int MTYP_CANCSB = 55;

            /// <summary>
            /// Magnet on Track detector
            /// </summary>
			public const int MTYP_CANMAG = 56;

            /// <summary>
            /// 16 input equivaent to CANACE8C
            /// </summary>
			public const int MTYP_CANACE16CMIO = 57;

            /// <summary>
            /// CBUS module based on Raspberry Pi
            /// </summary>
			public const int MTYP_CANPiNODE = 58;

            /// <summary>
            /// 25K80 version of CANLED64 (IHart and MB)
            /// </summary>
			public const int MTYP_CANDISP = 59;

            /// <summary>
            /// Compute Event processing engine
            /// </summary>
			public const int MTYP_CANCOMPUTE = 60;

            /// <summary>
            /// Read/Write from/to RC522 RFID tags
            /// </summary>
			public const int MTYP_CANRC522 = 61;

            /// <summary>
            /// 8 inputs module (2g version of CANACE8c) (Pete Brownlow)
            /// </summary>
			public const int MTYP_CANINP = 62;

            /// <summary>
            /// 8 outputs module (2g version of CANACC8) (Pete Brownlow)
            /// </summary>
			public const int MTYP_CANOUT = 63;

            /// <summary>
            /// Extended CANMIO (24 I/O ports) (Pete Brownlow)
            /// </summary>
			public const int MTYP_CANEMIO = 64;

            /// <summary>
            /// DC cab
            /// </summary>
			public const int MTYP_CANCABDC = 65;

            /// <summary>
            /// DC Railcom detector/reader
            /// </summary>
			public const int MTYP_CANRCOM = 66;

            /// <summary>
            /// MP3 sound player in response to events (eg: station announcements) (Duncan Greenwood)
            /// </summary>
			public const int MTYP_CANMP3 = 67;

            /// <summary>
            /// Addressed RGB LED driver (Duncan Greenwood)
            /// </summary>
			public const int MTYP_CANXMAS = 68;

            /// <summary>
            /// Servo setting box (Duncan Greenwood)
            /// </summary>
			public const int MTYP_CANSVOSET = 69;

            /// <summary>
            /// DC Command station
            /// </summary>
			public const int MTYP_CANCMDDC = 70;

            /// <summary>
            /// Text message display
            /// </summary>
			public const int MTYP_CANTEXT = 71;

            /// <summary>
            /// Signal controller
            /// </summary>
			public const int MTYP_CANASIGNAL = 72;

            /// <summary>
            /// DCC cab with slider control (Dave Radcliffe)
            /// </summary>
			public const int MTYP_CANSLIDER = 73;

            /// <summary>
            /// DC ATC module (Dave Harris)
            /// </summary>
			public const int MTYP_CANDCATC = 74;

            /// <summary>
            /// Logic module using and/or gates (Phil Silver)
            /// </summary>
			public const int MTYP_CANGATE = 75;

            /// <summary>
            /// Q series PIC input module (Ian Hart)
            /// </summary>
			public const int MTYP_CANSINP = 76;

            /// <summary>
            /// Q series PIC input module (Ian Hart)
            /// </summary>
			public const int MTYP_CANSOUT = 77;

            /// <summary>
            /// Q series PIC input module (Ian Hart)
            /// </summary>
			public const int MTYP_CANSBIP = 78;

            /// <summary>
            /// Message buffer (Phil Silver)
            /// </summary>
			public const int MTYP_CANBUFFER = 79;

            /// <summary>
            /// Lever frame module (Tim Coombs)
            /// </summary>
			public const int MTYP_CANLEVER = 80;

            /// <summary>
            /// Software nodes
            /// </summary>
			public const int MTYP_CAN_SW = 0xFF;

            /// <summary>
            /// Empty module, bootloader only
            /// </summary>
			public const int MTYP_EMPTY = 0xFE;

            /// <summary>
            /// USB interface
            /// </summary>
			public const int MTYP_CANUSB = 0xFD;
        }
        /// <summary>
        /// Microchip Processor type codes (identifies to FCU for bootload compatibility)
        /// </summary>
        public static class CbusMicrochipProcessors
        {

			public const int P18F2480 = 1;

			public const int P18F4480 = 2;

			public const int P18F2580 = 3;

			public const int P18F4580 = 4;

			public const int P18F2585 = 5;

			public const int P18F4585 = 6;

			public const int P18F2680 = 7;

			public const int P18F4680 = 8;

			public const int P18F2682 = 9;

			public const int P18F4682 = 10;

			public const int P18F2685 = 11;

			public const int P18F4685 = 12;

			public const int P18F25K80 = 13;

			public const int P18F45K80 = 14;

			public const int P18F26K80 = 15;

			public const int P18F46K80 = 16;

			public const int P18F65K80 = 17;

			public const int P18F66K80 = 18;

			public const int P18F25K83 = 19;

			public const int P18F26K83 = 20;

			public const int P18F27Q84 = 21;

			public const int P18F47Q84 = 22;

			public const int P18F27Q83 = 23;

			public const int P18F14K22 = 25;

			public const int P32MX534F064 = 30;

			public const int P32MX564F064 = 31;

			public const int P32MX564F128 = 32;

			public const int P32MX575F256 = 33;

			public const int P32MX575F512 = 34;

			public const int P32MX764F128 = 35;

			public const int P32MX775F256 = 36;

			public const int P32MX775F512 = 37;

			public const int P32MX795F512 = 38;
        }
        /// <summary>
        /// CBUS opcodes list
        /// Packets with no data bytes
        /// Packets with 1 data byte
        /// Packets with 2 data bytes
        /// Packets with 3 data bytes
        /// Packets with 4 data bytes
        /// Packets with 5 data bytes
        /// Packets with 6 data bytes
        /// Packets with 7 data bytes
        /// Opcodes that are proposed and/or agreed but not yet in the current published specification
        /// </summary>
        public static class CbusOpCodes
        {

            /// <summary>
            /// General ack
            /// </summary>
			public const int OPC_ACK = 0x00;

            /// <summary>
            /// General nak
            /// </summary>
			public const int OPC_NAK = 0x01;

            /// <summary>
            /// Bus Halt
            /// </summary>
			public const int OPC_HLT = 0x02;

            /// <summary>
            /// Bus on
            /// </summary>
			public const int OPC_BON = 0x03;

            /// <summary>
            /// Track off
            /// </summary>
			public const int OPC_TOF = 0x04;

            /// <summary>
            /// Track on
            /// </summary>
			public const int OPC_TON = 0x05;

            /// <summary>
            /// Track stopped
            /// </summary>
			public const int OPC_ESTOP = 0x06;

            /// <summary>
            /// System reset
            /// </summary>
			public const int OPC_ARST = 0x07;

            /// <summary>
            /// Request track off
            /// </summary>
			public const int OPC_RTOF = 0x08;

            /// <summary>
            /// Request track on
            /// </summary>
			public const int OPC_RTON = 0x09;

            /// <summary>
            /// Request emergency stop all
            /// </summary>
			public const int OPC_RESTP = 0x0a;

            /// <summary>
            /// Request node status
            /// </summary>
			public const int OPC_RSTAT = 0x0c;

            /// <summary>
            /// Query nodes
            /// </summary>
			public const int OPC_QNN = 0x0d;

            /// <summary>
            /// Read node parameters
            /// </summary>
			public const int OPC_RQNP = 0x10;

            /// <summary>
            /// Request name of module type
            /// </summary>
			public const int OPC_RQMN = 0x11;

            /// <summary>
            /// Release engine by handle
            /// </summary>
			public const int OPC_KLOC = 0x21;

            /// <summary>
            /// Query engine by handle
            /// </summary>
			public const int OPC_QLOC = 0x22;

            /// <summary>
            /// Keep alive for cab
            /// </summary>
			public const int OPC_DKEEP = 0x23;

            /// <summary>
            /// Debug message with 1 status byte
            /// </summary>
			public const int OPC_DBG1 = 0x30;

            /// <summary>
            /// Extended opcode
            /// </summary>
			public const int OPC_EXTC = 0x3F;

            /// <summary>
            /// Request session for loco
            /// </summary>
			public const int OPC_RLOC = 0x40;

            /// <summary>
            /// Query consist
            /// </summary>
			public const int OPC_QCON = 0x41;

            /// <summary>
            /// Set node number
            /// </summary>
			public const int OPC_SNN = 0x42;

            /// <summary>
            /// Allocate loco (used to allocate to a shuttle in cancmd)
            /// </summary>
			public const int OPC_ALOC = 0X43;

            /// <summary>
            /// Set Throttle mode
            /// </summary>
			public const int OPC_STMOD = 0x44;

            /// <summary>
            /// Consist loco
            /// </summary>
			public const int OPC_PCON = 0x45;

            /// <summary>
            /// De-consist loco
            /// </summary>
			public const int OPC_KCON = 0x46;

            /// <summary>
            /// Loco speed/dir
            /// </summary>
			public const int OPC_DSPD = 0x47;

            /// <summary>
            /// Set engine flags
            /// </summary>
			public const int OPC_DFLG = 0x48;

            /// <summary>
            /// Loco function on
            /// </summary>
			public const int OPC_DFNON = 0x49;

            /// <summary>
            /// Loco function off
            /// </summary>
			public const int OPC_DFNOF = 0x4A;

            /// <summary>
            /// Service mode status
            /// </summary>
			public const int OPC_SSTAT = 0x4C;

            /// <summary>
            /// Reset to manufacturer's defaults
            /// </summary>
			public const int OPC_NNRSM = 0x4F;

            /// <summary>
            /// Request Node number in setup mode
            /// </summary>
			public const int OPC_RQNN = 0x50;

            /// <summary>
            /// Node number release
            /// </summary>
			public const int OPC_NNREL = 0x51;

            /// <summary>
            /// Node number acknowledge
            /// </summary>
			public const int OPC_NNACK = 0x52;

            /// <summary>
            /// Set learn mode
            /// </summary>
			public const int OPC_NNLRN = 0x53;

            /// <summary>
            /// Release learn mode
            /// </summary>
			public const int OPC_NNULN = 0x54;

            /// <summary>
            /// Clear all events
            /// </summary>
			public const int OPC_NNCLR = 0x55;

            /// <summary>
            /// Read available event slots
            /// </summary>
			public const int OPC_NNEVN = 0x56;

            /// <summary>
            /// Read all stored events
            /// </summary>
			public const int OPC_NERD = 0x57;

            /// <summary>
            /// Read number of stored events
            /// </summary>
			public const int OPC_RQEVN = 0x58;

            /// <summary>
            /// Write acknowledge
            /// </summary>
			public const int OPC_WRACK = 0x59;

            /// <summary>
            /// Request node data event
            /// </summary>
			public const int OPC_RQDAT = 0x5A;

            /// <summary>
            /// Request short data frame
            /// </summary>
			public const int OPC_RQDDS = 0x5B;

            /// <summary>
            /// Put node into boot mode
            /// </summary>
			public const int OPC_BOOT = 0x5C;

            /// <summary>
            /// Force can_id self enumeration
            /// </summary>
			public const int OPC_ENUM = 0x5D;

            /// <summary>
            /// Reset node (as in restart)
            /// </summary>
			public const int OPC_NNRST = 0x5E;

            /// <summary>
            /// Extended opcode with 1 data byte
            /// </summary>
			public const int OPC_EXTC1 = 0x5F;

            /// <summary>
            /// Set engine functions
            /// </summary>
			public const int OPC_DFUN = 0x60;

            /// <summary>
            /// Get loco (with support for steal/share)
            /// </summary>
			public const int OPC_GLOC = 0x61;

            /// <summary>
            /// Command station error
            /// </summary>
			public const int OPC_ERR = 0x63;

            /// <summary>
            /// Errors from nodes during config
            /// </summary>
			public const int OPC_CMDERR = 0x6F;

            /// <summary>
            /// Event slots left response
            /// </summary>
			public const int OPC_EVNLF = 0x70;

            /// <summary>
            /// Request read of node variable
            /// </summary>
			public const int OPC_NVRD = 0x71;

            /// <summary>
            /// Request read stored event by index
            /// </summary>
			public const int OPC_NENRD = 0x72;

            /// <summary>
            /// Request read module parameters
            /// </summary>
			public const int OPC_RQNPN = 0x73;

            /// <summary>
            /// Number of events stored response
            /// </summary>
			public const int OPC_NUMEV = 0x74;

            /// <summary>
            /// Set canid
            /// </summary>
			public const int OPC_CANID = 0x75;

            /// <summary>
            /// Extended opcode with 2 data bytes
            /// </summary>
			public const int OPC_EXTC2 = 0x7F;

            /// <summary>
            /// 3 byte DCC packet
            /// </summary>
			public const int OPC_RDCC3 = 0x80;

            /// <summary>
            /// Write CV byte Ops mode by handle
            /// </summary>
			public const int OPC_WCVO = 0x82;

            /// <summary>
            /// Write CV bit Ops mode by handle
            /// </summary>
			public const int OPC_WCVB = 0x83;

            /// <summary>
            /// Read CV
            /// </summary>
			public const int OPC_QCVS = 0x84;

            /// <summary>
            /// Report CV
            /// </summary>
			public const int OPC_PCVS = 0x85;

            /// <summary>
            /// on event
            /// </summary>
			public const int OPC_ACON = 0x90;

            /// <summary>
            /// off event
            /// </summary>
			public const int OPC_ACOF = 0x91;

            /// <summary>
            /// Accessory Request event
            /// </summary>
			public const int OPC_AREQ = 0x92;

            /// <summary>
            /// Accessory response event on
            /// </summary>
			public const int OPC_ARON = 0x93;

            /// <summary>
            /// Accessory response event off
            /// </summary>
			public const int OPC_AROF = 0x94;

            /// <summary>
            /// Unlearn event
            /// </summary>
			public const int OPC_EVULN = 0x95;

            /// <summary>
            /// Set a node variable
            /// </summary>
			public const int OPC_NVSET = 0x96;

            /// <summary>
            /// Node variable value response
            /// </summary>
			public const int OPC_NVANS = 0x97;

            /// <summary>
            /// Short event on
            /// </summary>
			public const int OPC_ASON = 0x98;

            /// <summary>
            /// Short event off
            /// </summary>
			public const int OPC_ASOF = 0x99;

            /// <summary>
            /// Short Request event
            /// </summary>
			public const int OPC_ASRQ = 0x9A;

            /// <summary>
            /// Single node parameter response
            /// </summary>
			public const int OPC_PARAN = 0x9B;

            /// <summary>
            /// Request read of event variable
            /// </summary>
			public const int OPC_REVAL = 0x9C;

            /// <summary>
            /// Accessory short response on event
            /// </summary>
			public const int OPC_ARSON = 0x9D;

            /// <summary>
            /// Accessory short response off event
            /// </summary>
			public const int OPC_ARSOF = 0x9E;

            /// <summary>
            /// Extended opcode with 3 data bytes
            /// </summary>
			public const int OPC_EXTC3 = 0x9F;

            /// <summary>
            /// 4 byte DCC packet
            /// </summary>
			public const int OPC_RDCC4 = 0xA0;

            /// <summary>
            /// Write CV service mode
            /// </summary>
			public const int OPC_WCVS = 0xA2;

            /// <summary>
            /// On event with one data byte
            /// </summary>
			public const int OPC_ACON1 = 0xB0;

            /// <summary>
            /// Off event with one data byte
            /// </summary>
			public const int OPC_ACOF1 = 0xB1;

            /// <summary>
            /// Read event variable in learn mode
            /// </summary>
			public const int OPC_REQEV = 0xB2;

            /// <summary>
            /// Accessory on response (1 data byte)
            /// </summary>
			public const int OPC_ARON1 = 0xB3;

            /// <summary>
            /// Accessory off response (1 data byte)
            /// </summary>
			public const int OPC_AROF1 = 0xB4;

            /// <summary>
            /// Event variable by index read response
            /// </summary>
			public const int OPC_NEVAL = 0xB5;

            /// <summary>
            /// Response to QNN
            /// </summary>
			public const int OPC_PNN = 0xB6;

            /// <summary>
            /// Accessory short on with 1 data byte
            /// </summary>
			public const int OPC_ASON1 = 0xB8;

            /// <summary>
            /// Accessory short off with 1 data byte
            /// </summary>
			public const int OPC_ASOF1 = 0xB9;

            /// <summary>
            /// Short response event on with one data byte
            /// </summary>
			public const int OPC_ARSON1 = 0xBD;

            /// <summary>
            /// Short response event off with one data byte
            /// </summary>
			public const int OPC_ARSOF1 = 0xBE;

            /// <summary>
            /// Extended opcode with 4 data bytes
            /// </summary>
			public const int OPC_EXTC4 = 0xBF;

            /// <summary>
            /// 5 byte DCC packet
            /// </summary>
			public const int OPC_RDCC5 = 0xC0;

            /// <summary>
            /// Write CV ops mode by address
            /// </summary>
			public const int OPC_WCVOA = 0xC1;

            /// <summary>
            /// Cab data (cab signalling)
            /// </summary>
			public const int OPC_CABDAT = 0xC2;

            /// <summary>
            /// Fast clock
            /// </summary>
			public const int OPC_FCLK = 0xCF;

            /// <summary>
            /// On event with two data bytes
            /// </summary>
			public const int OPC_ACON2 = 0xD0;

            /// <summary>
            /// Off event with two data bytes
            /// </summary>
			public const int OPC_ACOF2 = 0xD1;

            /// <summary>
            /// Teach event
            /// </summary>
			public const int OPC_EVLRN = 0xd2;

            /// <summary>
            /// Event variable read response in learn mode
            /// </summary>
			public const int OPC_EVANS = 0xd3;

            /// <summary>
            /// Accessory on response
            /// </summary>
			public const int OPC_ARON2 = 0xD4;

            /// <summary>
            /// Accessory off response
            /// </summary>
			public const int OPC_AROF2 = 0xD5;

            /// <summary>
            /// Accessory short on with 2 data bytes
            /// </summary>
			public const int OPC_ASON2 = 0xD8;

            /// <summary>
            /// Accessory short off with 2 data bytes
            /// </summary>
			public const int OPC_ASOF2 = 0xD9;

            /// <summary>
            /// Short response event on with two data bytes
            /// </summary>
			public const int OPC_ARSON2 = 0xDD;

            /// <summary>
            /// Short response event off with two data bytes
            /// </summary>
			public const int OPC_ARSOF2 = 0xDE;

            /// <summary>
            /// Extended opcode with 5 data bytes
            /// </summary>
			public const int OPC_EXTC5 = 0xDF;

            /// <summary>
            /// 6 byte DCC packets
            /// </summary>
			public const int OPC_RDCC6 = 0xE0;

            /// <summary>
            /// Loco session report
            /// </summary>
			public const int OPC_PLOC = 0xE1;

            /// <summary>
            /// Module name response
            /// </summary>
			public const int OPC_NAME = 0xE2;

            /// <summary>
            /// Command station status report
            /// </summary>
			public const int OPC_STAT = 0xE3;

            /// <summary>
            /// Node parameters response
            /// </summary>
			public const int OPC_PARAMS = 0xEF;

            /// <summary>
            /// On event with 3 data bytes
            /// </summary>
			public const int OPC_ACON3 = 0xF0;

            /// <summary>
            /// Off event with 3 data bytes
            /// </summary>
			public const int OPC_ACOF3 = 0xF1;

            /// <summary>
            /// Read node events response
            /// </summary>
			public const int OPC_ENRSP = 0xF2;

            /// <summary>
            /// Accessory on response
            /// </summary>
			public const int OPC_ARON3 = 0xF3;

            /// <summary>
            /// Accessory off response
            /// </summary>
			public const int OPC_AROF3 = 0xF4;

            /// <summary>
            /// Teach event using event indexing
            /// </summary>
			public const int OPC_EVLRNI = 0xF5;

            /// <summary>
            /// Accessory data event: 5 bytes of node data (eg: RFID)
            /// </summary>
			public const int OPC_ACDAT = 0xF6;

            /// <summary>
            /// Accessory data response
            /// </summary>
			public const int OPC_ARDAT = 0xF7;

            /// <summary>
            /// Accessory short on with 3 data bytes
            /// </summary>
			public const int OPC_ASON3 = 0xF8;

            /// <summary>
            /// Accessory short off with 3 data bytes
            /// </summary>
			public const int OPC_ASOF3 = 0xF9;

            /// <summary>
            /// Short data frame aka device data event (device id plus 5 data bytes)
            /// </summary>
			public const int OPC_DDES = 0xFA;

            /// <summary>
            /// Short data frame response aka device data response
            /// </summary>
			public const int OPC_DDRS = 0xFB;

            /// <summary>
            /// Device Data Write Short
            /// </summary>
			public const int OPC_DDWS = 0xFC;

            /// <summary>
            /// Short response event on with 3 data bytes
            /// </summary>
			public const int OPC_ARSON3 = 0xFD;

            /// <summary>
            /// Short response event off with 3 data bytes
            /// </summary>
			public const int OPC_ARSOF3 = 0xFE;

            /// <summary>
            /// Extended opcode with 6 data byes
            /// </summary>
			public const int OPC_EXTC6 = 0xFF;

            /// <summary>
            /// Verify CV service mode - used for CV read hints
            /// </summary>
			public const int OPC_VCVS = 0xA4;

            /// <summary>
            /// CBUS long message packet
            /// </summary>
			public const int OPC_DTXC = 0xE9;
        }
        /// <summary>
        /// Flags in PAR_FLAGS
        /// </summary>
        public static class CbusParamFlags
        {

            /// <summary>
            /// Module doesn't support events
            /// </summary>
			public const int PF_NOEVENTS = 0;

            /// <summary>
            /// Module is a consumer of events
            /// </summary>
			public const int PF_CONSUMER = 1;

            /// <summary>
            /// Module is a producer of events
            /// </summary>
			public const int PF_PRODUCER = 2;

            /// <summary>
            /// Module is both a consumer and producer of events
            /// </summary>
			public const int PF_COMBI = 3;

            /// <summary>
            /// Module is in FLiM
            /// </summary>
			public const int PF_FLiM = 4;

            /// <summary>
            /// Module supports the FCU bootloader protocol
            /// </summary>
			public const int PF_BOOT = 8;

            /// <summary>
            /// Module can consume its own events
            /// </summary>
			public const int PF_COE = 16;

            /// <summary>
            /// Module is in learn mode
            /// </summary>
			public const int PF_LRN = 32;
        }
        /// <summary>
        /// Offsets to other values stored at the top of the parameter block.
        /// These are not returned by opcode PARAN, but are present in the hex
        /// file for FCU.
        /// </summary>
        public static class CbusParamOffsetsPic
        {

            /// <summary>
            /// Number of parameters implemented
            /// </summary>
			public const int PAR_COUNT = 0x18;

            /// <summary>
            /// 4 byte Address of Module type name, up to 8 characters null terminated
            /// </summary>
			public const int PAR_NAME = 0x1A;

            /// <summary>
            /// Checksum word at end of parameters
            /// </summary>
			public const int PAR_CKSUM = 0x1E;
        }
        /// <summary>
        /// Parameter index numbers (readable by OPC_RQNPN, returned in OPC_PARAN)
        /// Index numbers count from 1, subtract 1 for offset into parameter block
        /// Note that RQNPN with index 0 returns the parameter count
        /// </summary>
        public static class CbusParams
        {

            /// <summary>
            /// Manufacturer id
            /// </summary>
			public const int PAR_MANU = 1;

            /// <summary>
            /// Minor version letter
            /// </summary>
			public const int PAR_MINVER = 2;

            /// <summary>
            /// Module type code
            /// </summary>
			public const int PAR_MTYP = 3;

            /// <summary>
            /// Number of events supported
            /// </summary>
			public const int PAR_EVTNUM = 4;

            /// <summary>
            /// Event variables per event
            /// </summary>
			public const int PAR_EVNUM = 5;

            /// <summary>
            /// Number of Node variables
            /// </summary>
			public const int PAR_NVNUM = 6;

            /// <summary>
            /// Major version number
            /// </summary>
			public const int PAR_MAJVER = 7;

            /// <summary>
            /// Node flags
            /// </summary>
			public const int PAR_FLAGS = 8;

            /// <summary>
            /// Processor type
            /// </summary>
			public const int PAR_CPUID = 9;

            /// <summary>
            /// Bus type
            /// </summary>
			public const int PAR_BUSTYPE = 10;

            /// <summary>
            /// load address, 4 bytes
            /// </summary>
			public const int PAR_LOAD = 11;

            /// <summary>
            /// CPU manufacturer's id as read from the chip config space, 4 bytes (note - read from cpu at runtime, so not included in checksum)
            /// </summary>
			public const int PAR_CPUMID = 15;

            /// <summary>
            /// CPU manufacturer code
            /// </summary>
			public const int PAR_CPUMAN = 19;

            /// <summary>
            /// Beta revision (numeric), or 0 if release
            /// </summary>
			public const int PAR_BETA = 20;
        }
        /// <summary>
        /// Processor manufacturer codes
        /// </summary>
        public static class CbusProcessorManufacturers
        {

			public const int CPUM_MICROCHIP = 1;

			public const int CPUM_ATMEL = 2;

			public const int CPUM_ARM = 3;
        }
        /// <summary>
        /// Rocrail Module types
        /// </summary>
        public static class CbusRocRailModuleTypes
        {

            /// <summary>
            /// RS232 PC interface
            /// </summary>
			public const int MTYP_CANGC1 = 1;

            /// <summary>
            /// 16 I/O
            /// </summary>
			public const int MTYP_CANGC2 = 2;

            /// <summary>
            /// Command station (derived from cancmd)
            /// </summary>
			public const int MTYP_CANGC3 = 3;

            /// <summary>
            /// 8 channel RFID reader
            /// </summary>
			public const int MTYP_CANGC4 = 4;

            /// <summary>
            /// Cab for fixed panels (derived from cancab)
            /// </summary>
			public const int MTYP_CANGC5 = 5;

            /// <summary>
            /// 4 channel servo controller
            /// </summary>
			public const int MTYP_CANGC6 = 6;

            /// <summary>
            /// Fast clock module
            /// </summary>
			public const int MTYP_CANGC7 = 7;

            /// <summary>
            /// CAN<->Ethernet interface
            /// </summary>
			public const int MTYP_CANGC1e = 11;
        }
        /// <summary>
        /// Spectrum Engineering Animated Modeller module types
        /// </summary>
        public static class CbusSpectrumModuleTypes
        {

            /// <summary>
            /// Animation controller (firmware derived from cancmd)
            /// </summary>
			public const int MTYP_AMCTRLR = 1;

            /// <summary>
            /// Dual cab based on cancab
            /// </summary>
			public const int MTYP_DUALCAB = 2;
        }
        /// <summary>
        /// Sprog Module types
        /// </summary>
        public static class CbusSprogModuleTypes
        {

            /// <summary>
            /// Pi-SPROG 3 programmer/command station
            /// </summary>
			public const int MTYP_CANPiSPRG3 = 1;

            /// <summary>
            /// SPROG 3 Plus programmer/command station
            /// </summary>
			public const int MTYP_CANSPROG3P = 2;

            /// <summary>
            /// CAN SPROG programmer/command station
            /// </summary>
			public const int MTYP_CANSPROG = 3;

            /// <summary>
            /// System Booster
            /// </summary>
			public const int MTYP_CANSBOOST = 4;

            /// <summary>
            /// Pi-SPROG 3 Plus programmer/command station
            /// </summary>
			public const int MTYP_CANPiSPRGP = 5;

            /// <summary>
            /// 8-channel Servo I/O module
            /// </summary>
			public const int MTYP_CANSERVOIO = 50;

            /// <summary>
            /// CAN ISB Isolated CAN USB Interface
            /// </summary>
			public const int MTYP_CANISB = 100;
        }
        /// <summary>
        /// Status codes for OPC_SSTAT
        /// </summary>
        public static class CbusSStats
        {

			public const int SSTAT_NO_ACK = 1;

			public const int SSTAT_OVLD = 2;

			public const int SSTAT_WR_ACK = 3;

			public const int SSTAT_BUSY = 4;

			public const int SSTAT_CV_ERROR = 5;
        }
        /// <summary>
        /// Modes for STMOD
        /// </summary>
        public static class CbusStmodModes
        {

			public const int TMOD_SPD_MASK = 3;

			public const int TMOD_SPD_128 = 0;

			public const int TMOD_SPD_14 = 1;

			public const int TMOD_SPD_28I = 2;

			public const int TMOD_SPD_28 = 3;
        }
        /// <summary>
        /// SysPixie Module types (Konrad Orlowski)
        /// </summary>
        public static class CbusSysPixieModuleTypes
        {

            /// <summary>
            /// Motorised point motor driver with current sense
            /// </summary>
			public const int MTYP_CANPMSense = 1;
        }
    }
}
