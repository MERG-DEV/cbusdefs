/* DO NOT EDIT THIS FILE.
 * This file is automatically generated from cbusdefs.csv
 */

namespace merg.cbus
{
    // 
    // Copyright (C) Pete Brownlow 2011-2020   software@upsys.co.uk
    // Originally derived from opcodes.h (c) Andrew Crosland.
    // CSV version by Ian Hogg inspired by David W Radcliffe
    // 
    // Ver 8t
    // 
    //   This work is licensed under the:
    //       Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.
    //   To view a copy of this license, visit:
    //       http://creativecommons.org/licenses/by-nc-sa/4.0/
    //   or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.
    // 
    //   License summary:
    //     You are free to:
    //       Share, copy and redistribute the material in any medium or format
    //       Adapt, remix, transform, and build upon the material
    // 
    //     The licensor cannot revoke these freedoms as long as you follow the license terms.
    // 
    //     Attribution : You must give appropriate credit, provide a link to the license,
    //                    and indicate if changes were made. You may do so in any reasonable manner,
    //                    but not in any way that suggests the licensor endorses you or your use.
    // 
    //     NonCommercial : You may not use the material for commercial purposes. **(see note below)
    // 
    //     ShareAlike : If you remix, transform, or build upon the material, you must distribute
    //                   your contributions under the same license as the original.
    // 
    //     No additional restrictions : You may not apply legal terms or technological measures that
    //                                   legally restrict others from doing anything the license permits.
    // 
    //    ** For commercial use, please contact the original copyright holder(s) to agree licensing terms
    // 
    //     This software is distributed in the hope that it will be useful, but WITHOUT ANY
    //     WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE
    // 
    // Version history:
    // Pete Brownlow,6/4/11,Original from spec version 7e
    // Roger Healey,6/4/11,Add OPC_CMDERR response codes
    // Pete Brownlow,7/6/11,Updated to spec ver 7f and add new module ids
    // Pete Brownlow,4/7/11,Updated to spec ver 7g
    // Pete Brownlow,14/8/11,Updated to spec ver 7h
    // Pete Brownlow,18/2/12,Updated to spec ver 8a, Rocrail and animated modeller module types added
    // Pete Brownlow,10/4/12,Updated to spec ver 8b, extended parameter bytes
    // Pete Brownlow,17/4/12,Updated parameter block definitions, added processor type definitions.
    // Roger Healey,13/7/12,Add CANTOTI
    // Pete Brownlow,15/9/12,Updated to spec ver 8c, added 0x5D ENUM and 0x75 CANID
    // Pete Brownlow,4/1/13,Ver 8d New module types, added 0x5E  NNRST
    // Roger Healey,15/2/13,Now at version d. Added new Module Ids (as per ModuleIds Issue 9) and
    //          Align Processor Ids with constants.inc
    //          Added .(fullstop) before each processor Id > 9
    //          Added OPC_NNRST
    // Roger Healey,27/4/13,Added CANSIG8 and CANSIG64
    // Roger Healey,6/8/13,Added CANCOND8C
    // Roger Healey,22/1/14,Added CANPAN, CANACE3C, CANPanel and CANMIO
    // Pete Brownlow,22/1/14,Ver 8g New module types, OPC_NNRST & OPC_NNRSM, catch up with .inc file
    //          Added parameter definitions for manufacturer's CPU id
    //          Added extern C so can be included by c++ code
    //          Fixed CANGC1e type definition
    // Phil Wheeler,1/2/14,Corrected some typos. Added PRM_BETA, dotted some more decimal numbers
    // Phil Wheeler,9/3/14,Corrected CANSIG MTYP definitions
    // Pete Brownlow,19/4/14,Ver 8h Added module type defs for CANTOTIMIO, CANACE8MIO, CANBIP, CANSOL
    // Pete Brownlow,06/7/15,Ver 8j Add new module types as per modules definitions v17 : CANCDU, CANACC4CDU, CANWiBase, WiCAB, CANWiFi, CANFTT
    //          Add new opcode ALOC, added CPU manufacturer code CPUM_ATMEL
    // Mike Bolton,2/3/16,Ver 8k    Add module type CANRFID8
    // Pete Brownlow,2/7/16,Ver 8m Add new module types CANHNDST, CANTCHNDST, CANmchRFID and CANPiWi
    //          Add processor codes for ARM chips used in Raspberry Pi's
    // Pete Brownlow,16/2/17,Ver 8n Add module ids to bring it up to module ids document ver 25
    // Pete Brownlow,29/7/17,Ver 8p Add new module ids and new cab signalling opcode
    // Pete Brownlow,09/1/18,Ver 8q Add new parameter flag for module can consume its own events
    // Ian Hogg,11/9/18,Ver 8r Added CANACE16CMIO, CANPiNODE, CANDISP, CANCOMPUTE
    // Richard Crawshaw,29/02/2020,Fixed order of columns in CbusCabSigAspect2.
    // Pete Brownlow,01/09/20,Ver 8s for additional module ids defined in the ModuleIds file ver 33.
    //                        Updated descriptive comments for some module types
    //                        Updated CABDAT opcode to match RFC0004
    // Pete Brownlow,06/09/20,Ver 8t Added module type for CANRCOM. Fixed: Opcode for CABDAT, names for CANRC522 and CANMAG
    // Andrew Crosland,21/09/21,Ver 8t Added PICs P18F14K22 P18F26K83 P18F27Q84 P18F47Q84 and P18F27Q83
    // Duncan Greenwood,21/10/07,Ver 8t Added OPC_DTXC opcode (0xE9) for CBUS long messages
    // 

    /// <summary>
    /// ARM Processor type codes (identifies to FCU for bootload compatiblity)
    /// </summary>
    public enum ArmProcessors
    {

        /// <summary>
        /// As used in Raspberry Pi
        /// </summary>
        Arm1176jzfS = 1, // ARM1176JZF_S

        /// <summary>
        /// As Used in Raspberry Pi 2
        /// </summary>
        ArmcortexA7 = 2, // ARMCortex_A7

        /// <summary>
        /// As used in Raspberry Pi 3
        /// </summary>
        ArmcortexA53 = 3, // ARMCortex_A53
    }

    /// <summary>
    /// BUS type that module is connected to
    /// </summary>
    public enum BusTypes
    {

        PbCan = 1, // PB_CAN

        PbEth = 2, // PB_ETH

        PbMiwi = 3, // PB_MIWI
    }

    /// <summary>
    /// Sub opcodes for OPC_CABDAT
    /// </summary>
    public enum CabSigAspect0
    {

        CdatCabsig = 1, // CDAT_CABSIG
    }

    /// <summary>
    /// Aspect codes for CDAT_CABSIG
    /// First aspect byte
    /// </summary>
    public enum CabSigAspect1
    {

        Danger = 0, // SASP_DANGER

        Caution = 1, // SASP_CAUTION

        PrelimCaution = 2, // SASP_PRELIM_CAUTION

        Proceed = 3, // SASP_PROCEED

        /// <summary>
        /// Set bit 2 for call-on - main aspect will usually be at danger
        /// </summary>
        Callon = 4, // SASP_CALLON

        /// <summary>
        /// Set bit 3 to 0 for upper nibble is feather lcoation, set 1 for upper nibble is theatre code
        /// </summary>
        Theatre = 8, // SASP_THEATRE
    }

    /// <summary>
    /// Aspect codes for CDAT_CABSIG
    /// Second Aspect byte
    /// Remaining bits in second aspect byte yet to be defined - can be used for other signalling systems
    /// </summary>
    public enum CabSigAspect2
    {

        /// <summary>
        /// Set bit 0 to indicate lit
        /// </summary>
        Lit = 0, // SASP_LIT

        /// <summary>
        /// Set bit 1 for lunar indication
        /// </summary>
        Lunar = 1, // SASP_LUNAR
    }

    /// <summary>
    /// Error codes for OPC_CMDERR
    /// </summary>
    public enum CmdErrs
    {

        InvCmd = 1, // CMDERR_INV_CMD

        NotLrn = 2, // CMDERR_NOT_LRN

        NotSetup = 3, // CMDERR_NOT_SETUP

        TooManyEvents = 4, // CMDERR_TOO_MANY_EVENTS

        NoEv = 5, // CMDERR_NO_EV

        InvEvIdx = 6, // CMDERR_INV_EV_IDX

        InvalidEvent = 7, // CMDERR_INVALID_EVENT

        /// <summary>
        /// now reserved
        /// </summary>
        InvEnIdx = 8, // CMDERR_INV_EN_IDX

        InvParamIdx = 9, // CMDERR_INV_PARAM_IDX

        InvNvIdx = 10, // CMDERR_INV_NV_IDX

        InvEvValue = 11, // CMDERR_INV_EV_VALUE

        InvNvValue = 12, // CMDERR_INV_NV_VALUE
    }

    /// <summary>
    /// Error codes for OPC_ERR
    /// </summary>
    public enum Errs
    {

        LocoStackFull = 1, // ERR_LOCO_STACK_FULL

        LocoAddrTaken = 2, // ERR_LOCO_ADDR_TAKEN

        SessionNotPresent = 3, // ERR_SESSION_NOT_PRESENT

        ConsistEmpty = 4, // ERR_CONSIST_EMPTY

        LocoNotFound = 5, // ERR_LOCO_NOT_FOUND

        CmdRxBufOflow = 6, // ERR_CMD_RX_BUF_OFLOW

        InvalidRequest = 7, // ERR_INVALID_REQUEST

        SessionCancelled = 8, // ERR_SESSION_CANCELLED
    }

    /// <summary>
    /// CBUS Manufacturer definitions
    /// Where the manufacturer already has an NMRA code, this is used
    /// </summary>
    public enum Manufacturer
    {

        /// <summary>
        /// http://www.merg.co.uk
        /// </summary>
        Merg = 165, // MANU_MERG

        /// <summary>
        /// http://www.rocrail.net
        /// </summary>
        Rocrail = 70, // MANU_ROCRAIL

        /// <summary>
        /// http://animatedmodeler.com  (Spectrum Engineering)
        /// </summary>
        Spectrum = 80, // MANU_SPECTRUM
    }

    /// <summary>
    /// MODULE TYPES
    /// Please note that the existance of a module type id does not necessarily mean that firmware has been implemented
    /// MERG Module types
    /// At the time of writing the list of defined MERG module types is maintained by Roger Healey
    /// Please liaise with Roger before adding new module types
    /// </summary>
    public enum MergModuleTypes
    {

        /// <summary>
        /// default for SLiM nodes
        /// </summary>
        Slim = 0, // MTYP_SLIM

        /// <summary>
        /// Solenoid point driver
        /// </summary>
        Canacc4 = 1, // MTYP_CANACC4

        /// <summary>
        /// Motorised point driver
        /// </summary>
        Canacc5 = 2, // MTYP_CANACC5

        /// <summary>
        /// 8 digital outputs
        /// </summary>
        Canacc8 = 3, // MTYP_CANACC8

        /// <summary>
        /// Control panel switch/button encoder
        /// </summary>
        Canace3 = 4, // MTYP_CANACE3

        /// <summary>
        /// 8 digital inputs
        /// </summary>
        Canace8c = 5, // MTYP_CANACE8C

        /// <summary>
        /// 64 led driver
        /// </summary>
        Canled = 6, // MTYP_CANLED

        /// <summary>
        /// 64 led driver (multi leds per event)
        /// </summary>
        Canled64 = 7, // MTYP_CANLED64

        /// <summary>
        /// 12v version of CANACC4
        /// </summary>
        Canacc42 = 8, // MTYP_CANACC4_2

        /// <summary>
        /// CANCAB hand throttle
        /// </summary>
        Cancab = 9, // MTYP_CANCAB

        /// <summary>
        /// CANCMD command station
        /// </summary>
        Cancmd = 10, // MTYP_CANCMD

        /// <summary>
        /// 8 servo driver (on canacc8 or similar hardware)
        /// </summary>
        Canservo = 11, // MTYP_CANSERVO

        /// <summary>
        /// BC1a command station
        /// </summary>
        Canbc = 12, // MTYP_CANBC

        /// <summary>
        /// RPI and RFID interface
        /// </summary>
        Canrpi = 13, // MTYP_CANRPI

        /// <summary>
        /// Turntable controller (turntable end)
        /// </summary>
        Canttca = 14, // MTYP_CANTTCA

        /// <summary>
        /// Turntable controller (control panel end)
        /// </summary>
        Canttcb = 15, // MTYP_CANTTCB

        /// <summary>
        /// Handset controller for old BC1a type handsets
        /// </summary>
        Canhs = 16, // MTYP_CANHS

        /// <summary>
        /// Track occupancy detector
        /// </summary>
        Cantoti = 17, // MTYP_CANTOTI

        /// <summary>
        /// 8 inputs 8 outputs
        /// </summary>
        Can8i8o = 18, // MTYP_CAN8I8O

        /// <summary>
        /// Canservo with servo position feedback
        /// </summary>
        Canservo8c = 19, // MTYP_CANSERVO8C

        /// <summary>
        /// RFID input
        /// </summary>
        Canrfid = 20, // MTYP_CANRFID

        Cantc4 = 21, // MTYP_CANTC4

        /// <summary>
        /// 16 inputs
        /// </summary>
        Canace16c = 22, // MTYP_CANACE16C

        /// <summary>
        /// 8 way I/O
        /// </summary>
        Canio8 = 23, // MTYP_CANIO8

        /// <summary>
        /// ??
        /// </summary>
        Cansndx = 24, // MTYP_CANSNDX

        /// <summary>
        /// Ethernet interface
        /// </summary>
        Canether = 25, // MTYP_CANEther

        /// <summary>
        /// Multiple aspect signalling for CANLED module
        /// </summary>
        Cansig64 = 26, // MTYP_CANSIG64

        /// <summary>
        /// Multiple aspect signalling for CANACC8 module
        /// </summary>
        Cansig8 = 27, // MTYP_CANSIG8

        /// <summary>
        /// Conditional event generation
        /// </summary>
        Cancond8c = 28, // MTYP_CANCOND8C

        /// <summary>
        /// Control panel 32/32
        /// </summary>
        Canpan = 29, // MTYP_CANPAN

        /// <summary>
        /// Newer version of CANACE3 firmware
        /// </summary>
        Canace3c = 30, // MTYP_CANACE3C

        /// <summary>
        /// Control panel 64/64
        /// </summary>
        Canpanel = 31, // MTYP_CANPanel

        /// <summary>
        /// Multiple I/O – Universal CANMIO firmware
        /// </summary>
        Canmio = 32, // MTYP_CANMIO

        /// <summary>
        /// Multiple IO module 16 inputs emulating CANACE8C on CANMIO hardware
        /// </summary>
        Canace8mio = 33, // MTYP_CANACE8MIO

        /// <summary>
        /// Solenoid driver module
        /// </summary>
        Cansol = 34, // MTYP_CANSOL

        /// <summary>
        /// Universal CANBIP firmware - Bipolar IO module with additional 8 I/O pins (CANMIO family)
        /// </summary>
        Canbip = 35, // MTYP_CANBIP

        /// <summary>
        /// Solenoid driver module with additional 6 I/O pins (CANMIO family)
        /// </summary>
        Cancdu = 36, // MTYP_CANCDU

        /// <summary>
        /// CANACC4 firmware ported to CANCDU
        /// </summary>
        Canacc4cdu = 37, // MTYP_CANACC4CDU

        /// <summary>
        /// CAN to MiWi base station
        /// </summary>
        Canwibase = 38, // MTYP_CANWiBase

        /// <summary>
        /// Wireless cab using MiWi protocol
        /// </summary>
        Wicab = 39, // MTYP_WiCAB

        /// <summary>
        /// CAN to WiFi connection with Withrottle to CBUS protocol conversion
        /// </summary>
        Canwifi = 40, // MTYP_CANWiFi

        /// <summary>
        /// Turntable controller configured using FLiM
        /// </summary>
        Canftt = 41, // MTYP_CANFTT

        /// <summary>
        /// Handset (alternative to CANCAB)
        /// </summary>
        Canhndst = 42, // MTYP_CANHNDST

        /// <summary>
        /// Touchscreen handset
        /// </summary>
        Cantchndst = 43, // MTYP_CANTCHNDST

        /// <summary>
        /// multi-channel RFID reader
        /// </summary>
        Canrfid8 = 44, // MTYP_CANRFID8

        /// <summary>
        /// either a 2ch or 8ch RFID reader
        /// </summary>
        Canmchrfid = 45, // MTYP_CANmchRFID

        /// <summary>
        /// a Raspberry Pi based module for WiFi
        /// </summary>
        Canpiwi = 46, // MTYP_CANPiWi

        /// <summary>
        /// DC train controller
        /// </summary>
        Can4dc = 47, // MTYP_CAN4DC

        /// <summary>
        /// Nelevator controller
        /// </summary>
        Canelev = 48, // MTYP_CANELEV

        /// <summary>
        /// 128 switch inputs
        /// </summary>
        Canscan = 49, // MTYP_CANSCAN

        /// <summary>
        /// 16MHz 25k80 version of CANSERVO8c on CANMIO hardware
        /// </summary>
        CanmioSvo = 50, // MTYP_CANMIO_SVO

        /// <summary>
        /// 16MHz 25k80 version of CANACE8MIO on CANMIO hardware
        /// </summary>
        CanmioInp = 51, // MTYP_CANMIO_INP

        /// <summary>
        /// 16MHz 25k80 version of CANACC8 on CANMIO hardware
        /// </summary>
        CanmioOut = 52, // MTYP_CANMIO_OUT

        /// <summary>
        /// 16MHz 25k80 version of CANACC5 on CANBIP hardware
        /// </summary>
        CanbipOut = 53, // MTYP_CANBIP_OUT

        /// <summary>
        /// DCC stop generator
        /// </summary>
        Canastop = 54, // MTYP_CANASTOP

        /// <summary>
        /// CANCMD with on board 3A booster
        /// </summary>
        Cancsb = 55, // MTYP_CANCSB

        /// <summary>
        /// Magnet on Track detector
        /// </summary>
        Canmag = 56, // MTYP_CANMAG

        /// <summary>
        /// 16 input equivaent to CANACE8C
        /// </summary>
        Canace16cmio = 57, // MTYP_CANACE16CMIO

        /// <summary>
        /// CBUS module based on Raspberry Pi
        /// </summary>
        Canpinode = 58, // MTYP_CANPiNODE

        /// <summary>
        /// 25K80 version of CANLED64 (IHart and MB)
        /// </summary>
        Candisp = 59, // MTYP_CANDISP

        /// <summary>
        /// Compute Event processing engine
        /// </summary>
        Cancompute = 60, // MTYP_CANCOMPUTE

        /// <summary>
        /// Read/Write from/to RC522 RFID tags
        /// </summary>
        Canrc522 = 61, // MTYP_CANRC522

        /// <summary>
        /// 8 inputs module (2g version of CANACE8c)
        /// </summary>
        Caninp = 62, // MTYP_CANINP

        /// <summary>
        /// 8 outputs module (2g version of CANACC8)
        /// </summary>
        Canout = 63, // MTYP_CANOUT

        /// <summary>
        /// Extended CANMIO (24 I/O ports)
        /// </summary>
        Canemio = 64, // MTYP_CANEMIO

        /// <summary>
        /// DC cab
        /// </summary>
        Cancabdc = 65, // MTYP_CANCABDC

        /// <summary>
        /// DC Railcom detector/reader
        /// </summary>
        Canrcom = 66, // MTYP_CANRCOM

        /// <summary>
        /// Software nodes
        /// </summary>
        CanSw = 0xFF, // MTYP_CAN_SW

        /// <summary>
        /// Empty module, bootloader only
        /// </summary>
        Empty = 0xFE, // MTYP_EMPTY

        /// <summary>
        /// USB interface
        /// </summary>
        Canusb = 0xFD, // MTYP_CANUSB
    }

    /// <summary>
    /// Microchip Processor type codes (identifies to FCU for bootload compatiblity)
    /// </summary>
    public enum MicrochipProcessors
    {

        P18f2480 = 1, // P18F2480

        P18f4480 = 2, // P18F4480

        P18f2580 = 3, // P18F2580

        P18f4580 = 4, // P18F4580

        P18f2585 = 5, // P18F2585

        P18f4585 = 6, // P18F4585

        P18f2680 = 7, // P18F2680

        P18f4680 = 8, // P18F4680

        P18f2682 = 9, // P18F2682

        P18f4682 = 10, // P18F4682

        P18f2685 = 11, // P18F2685

        P18f4685 = 12, // P18F4685

        P18f25k80 = 13, // P18F25K80

        P18f45k80 = 14, // P18F45K80

        P18f26k80 = 15, // P18F26K80

        P18f46k80 = 16, // P18F46K80

        P18f65k80 = 17, // P18F65K80

        P18f66k80 = 18, // P18F66K80

        P18f14k22 = 19, // P18F14K22

        P18f26k83 = 20, // P18F26K83

        P18f27q84 = 21, // P18F27Q84

        P18f47q84 = 22, // P18F47Q84

        P18f27q83 = 23, // P18F27Q83

        P32mx534f064 = 30, // P32MX534F064

        P32mx564f064 = 31, // P32MX564F064

        P32mx564f128 = 32, // P32MX564F128

        P32mx575f256 = 33, // P32MX575F256

        P32mx575f512 = 34, // P32MX575F512

        P32mx764f128 = 35, // P32MX764F128

        P32mx775f256 = 36, // P32MX775F256

        P32mx775f512 = 37, // P32MX775F512

        P32mx795f512 = 38, // P32MX795F512
    }

    /// <summary>
    /// CBUS opcodes list
    /// Packets with no data bytes
    /// Packets with 1 data byte
    /// Packets with 2 data bytes
    /// Packets with 3 data bytes
    /// Packets with 4 data bytes
    /// Packets with 5 data bytes
    /// Packets with 6 data bytes
    /// Packets with 7 data bytes
    /// </summary>
    public enum OpCodes
    {

        /// <summary>
        /// General ack
        /// </summary>
        Ack = 0x00, // OPC_ACK

        /// <summary>
        /// General nak
        /// </summary>
        Nak = 0x01, // OPC_NAK

        /// <summary>
        /// Bus Halt
        /// </summary>
        Hlt = 0x02, // OPC_HLT

        /// <summary>
        /// Bus on
        /// </summary>
        Bon = 0x03, // OPC_BON

        /// <summary>
        /// Track off
        /// </summary>
        Tof = 0x04, // OPC_TOF

        /// <summary>
        /// Track on
        /// </summary>
        Ton = 0x05, // OPC_TON

        /// <summary>
        /// Track stopped
        /// </summary>
        Estop = 0x06, // OPC_ESTOP

        /// <summary>
        /// System reset
        /// </summary>
        Arst = 0x07, // OPC_ARST

        /// <summary>
        /// Request track off
        /// </summary>
        Rtof = 0x08, // OPC_RTOF

        /// <summary>
        /// Request track on
        /// </summary>
        Rton = 0x09, // OPC_RTON

        /// <summary>
        /// Request emergency stop all
        /// </summary>
        Restp = 0x0a, // OPC_RESTP

        /// <summary>
        /// Request node status
        /// </summary>
        Rstat = 0x0c, // OPC_RSTAT

        /// <summary>
        /// Query nodes
        /// </summary>
        Qnn = 0x0d, // OPC_QNN

        /// <summary>
        /// Read node parameters
        /// </summary>
        Rqnp = 0x10, // OPC_RQNP

        /// <summary>
        /// Request name of module type
        /// </summary>
        Rqmn = 0x11, // OPC_RQMN

        /// <summary>
        /// Release engine by handle
        /// </summary>
        Kloc = 0x21, // OPC_KLOC

        /// <summary>
        /// Query engine by handle
        /// </summary>
        Qloc = 0x22, // OPC_QLOC

        /// <summary>
        /// Keep alive for cab
        /// </summary>
        Dkeep = 0x23, // OPC_DKEEP

        /// <summary>
        /// Debug message with 1 status byte
        /// </summary>
        Dbg1 = 0x30, // OPC_DBG1

        /// <summary>
        /// Extended opcode
        /// </summary>
        Extc = 0x3F, // OPC_EXTC

        /// <summary>
        /// Request session for loco
        /// </summary>
        Rloc = 0x40, // OPC_RLOC

        /// <summary>
        /// Query consist
        /// </summary>
        Qcon = 0x41, // OPC_QCON

        /// <summary>
        /// Set node number
        /// </summary>
        Snn = 0x42, // OPC_SNN

        /// <summary>
        /// Allocate loco (used to allocate to a shuttle in cancmd)
        /// </summary>
        Aloc = 0X43, // OPC_ALOC

        /// <summary>
        /// Set Throttle mode
        /// </summary>
        Stmod = 0x44, // OPC_STMOD

        /// <summary>
        /// Consist loco
        /// </summary>
        Pcon = 0x45, // OPC_PCON

        /// <summary>
        /// De-consist loco
        /// </summary>
        Kcon = 0x46, // OPC_KCON

        /// <summary>
        /// Loco speed/dir
        /// </summary>
        Dspd = 0x47, // OPC_DSPD

        /// <summary>
        /// Set engine flags
        /// </summary>
        Dflg = 0x48, // OPC_DFLG

        /// <summary>
        /// Loco function on
        /// </summary>
        Dfnon = 0x49, // OPC_DFNON

        /// <summary>
        /// Loco function off
        /// </summary>
        Dfnof = 0x4A, // OPC_DFNOF

        /// <summary>
        /// Service mode status
        /// </summary>
        Sstat = 0x4C, // OPC_SSTAT

        /// <summary>
        /// Reset to manufacturer's defaults
        /// </summary>
        Nnrsm = 0x4F, // OPC_NNRSM

        /// <summary>
        /// Request Node number in setup mode
        /// </summary>
        Rqnn = 0x50, // OPC_RQNN

        /// <summary>
        /// Node number release
        /// </summary>
        Nnrel = 0x51, // OPC_NNREL

        /// <summary>
        /// Node number acknowledge
        /// </summary>
        Nnack = 0x52, // OPC_NNACK

        /// <summary>
        /// Set learn mode
        /// </summary>
        Nnlrn = 0x53, // OPC_NNLRN

        /// <summary>
        /// Release learn mode
        /// </summary>
        Nnuln = 0x54, // OPC_NNULN

        /// <summary>
        /// Clear all events
        /// </summary>
        Nnclr = 0x55, // OPC_NNCLR

        /// <summary>
        /// Read available event slots
        /// </summary>
        Nnevn = 0x56, // OPC_NNEVN

        /// <summary>
        /// Read all stored events
        /// </summary>
        Nerd = 0x57, // OPC_NERD

        /// <summary>
        /// Read number of stored events
        /// </summary>
        Rqevn = 0x58, // OPC_RQEVN

        /// <summary>
        /// Write acknowledge
        /// </summary>
        Wrack = 0x59, // OPC_WRACK

        /// <summary>
        /// Request node data event
        /// </summary>
        Rqdat = 0x5A, // OPC_RQDAT

        /// <summary>
        /// Request short data frame
        /// </summary>
        Rqdds = 0x5B, // OPC_RQDDS

        /// <summary>
        /// Put node into boot mode
        /// </summary>
        Boot = 0x5C, // OPC_BOOT

        /// <summary>
        /// Force can_id self enumeration
        /// </summary>
        Enum = 0x5D, // OPC_ENUM

        /// <summary>
        /// Reset node (as in restart)
        /// </summary>
        Nnrst = 0x5E, // OPC_NNRST

        /// <summary>
        /// Extended opcode with 1 data byte
        /// </summary>
        Extc1 = 0x5F, // OPC_EXTC1

        /// <summary>
        /// Set engine functions
        /// </summary>
        Dfun = 0x60, // OPC_DFUN

        /// <summary>
        /// Get loco (with support for steal/share)
        /// </summary>
        Gloc = 0x61, // OPC_GLOC

        /// <summary>
        /// Command station error
        /// </summary>
        Err = 0x63, // OPC_ERR

        /// <summary>
        /// Errors from nodes during config
        /// </summary>
        Cmderr = 0x6F, // OPC_CMDERR

        /// <summary>
        /// Event slots left response
        /// </summary>
        Evnlf = 0x70, // OPC_EVNLF

        /// <summary>
        /// Request read of node variable
        /// </summary>
        Nvrd = 0x71, // OPC_NVRD

        /// <summary>
        /// Request read stored event by index
        /// </summary>
        Nenrd = 0x72, // OPC_NENRD

        /// <summary>
        /// Request read module parameters
        /// </summary>
        Rqnpn = 0x73, // OPC_RQNPN

        /// <summary>
        /// Number of events stored response
        /// </summary>
        Numev = 0x74, // OPC_NUMEV

        /// <summary>
        /// Set canid
        /// </summary>
        Canid = 0x75, // OPC_CANID

        /// <summary>
        /// Extended opcode with 2 data bytes
        /// </summary>
        Extc2 = 0x7F, // OPC_EXTC2

        /// <summary>
        /// 3 byte DCC packet
        /// </summary>
        Rdcc3 = 0x80, // OPC_RDCC3

        /// <summary>
        /// Write CV byte Ops mode by handle
        /// </summary>
        Wcvo = 0x82, // OPC_WCVO

        /// <summary>
        /// Write CV bit Ops mode by handle
        /// </summary>
        Wcvb = 0x83, // OPC_WCVB

        /// <summary>
        /// Read CV
        /// </summary>
        Qcvs = 0x84, // OPC_QCVS

        /// <summary>
        /// Report CV
        /// </summary>
        Pcvs = 0x85, // OPC_PCVS

        /// <summary>
        /// on event
        /// </summary>
        Acon = 0x90, // OPC_ACON

        /// <summary>
        /// off event
        /// </summary>
        Acof = 0x91, // OPC_ACOF

        /// <summary>
        /// Accessory Request event
        /// </summary>
        Areq = 0x92, // OPC_AREQ

        /// <summary>
        /// Accessory response event on
        /// </summary>
        Aron = 0x93, // OPC_ARON

        /// <summary>
        /// Accessory response event off
        /// </summary>
        Arof = 0x94, // OPC_AROF

        /// <summary>
        /// Unlearn event
        /// </summary>
        Evuln = 0x95, // OPC_EVULN

        /// <summary>
        /// Set a node variable
        /// </summary>
        Nvset = 0x96, // OPC_NVSET

        /// <summary>
        /// Node variable value response
        /// </summary>
        Nvans = 0x97, // OPC_NVANS

        /// <summary>
        /// Short event on
        /// </summary>
        Ason = 0x98, // OPC_ASON

        /// <summary>
        /// Short event off
        /// </summary>
        Asof = 0x99, // OPC_ASOF

        /// <summary>
        /// Short Request event
        /// </summary>
        Asrq = 0x9A, // OPC_ASRQ

        /// <summary>
        /// Single node parameter response
        /// </summary>
        Paran = 0x9B, // OPC_PARAN

        /// <summary>
        /// Request read of event variable
        /// </summary>
        Reval = 0x9C, // OPC_REVAL

        /// <summary>
        /// Accessory short response on event
        /// </summary>
        Arson = 0x9D, // OPC_ARSON

        /// <summary>
        /// Accessory short response off event
        /// </summary>
        Arsof = 0x9E, // OPC_ARSOF

        /// <summary>
        /// Extended opcode with 3 data bytes
        /// </summary>
        Extc3 = 0x9F, // OPC_EXTC3

        /// <summary>
        /// 4 byte DCC packet
        /// </summary>
        Rdcc4 = 0xA0, // OPC_RDCC4

        /// <summary>
        /// Write CV service mode
        /// </summary>
        Wcvs = 0xA2, // OPC_WCVS

        /// <summary>
        /// On event with one data byte
        /// </summary>
        Acon1 = 0xB0, // OPC_ACON1

        /// <summary>
        /// Off event with one data byte
        /// </summary>
        Acof1 = 0xB1, // OPC_ACOF1

        /// <summary>
        /// Read event variable in learn mode
        /// </summary>
        Reqev = 0xB2, // OPC_REQEV

        /// <summary>
        /// Accessory on response (1 data byte)
        /// </summary>
        Aron1 = 0xB3, // OPC_ARON1

        /// <summary>
        /// Accessory off response (1 data byte)
        /// </summary>
        Arof1 = 0xB4, // OPC_AROF1

        /// <summary>
        /// Event variable by index read response
        /// </summary>
        Neval = 0xB5, // OPC_NEVAL

        /// <summary>
        /// Response to QNN
        /// </summary>
        Pnn = 0xB6, // OPC_PNN

        /// <summary>
        /// Accessory short on with 1 data byte
        /// </summary>
        Ason1 = 0xB8, // OPC_ASON1

        /// <summary>
        /// Accessory short off with 1 data byte
        /// </summary>
        Asof1 = 0xB9, // OPC_ASOF1

        /// <summary>
        /// Short response event on with one data byte
        /// </summary>
        Arson1 = 0xBD, // OPC_ARSON1

        /// <summary>
        /// Short response event off with one data byte
        /// </summary>
        Arsof1 = 0xBE, // OPC_ARSOF1

        /// <summary>
        /// Extended opcode with 4 data bytes
        /// </summary>
        Extc4 = 0xBF, // OPC_EXTC4

        /// <summary>
        /// 5 byte DCC packet
        /// </summary>
        Rdcc5 = 0xC0, // OPC_RDCC5

        /// <summary>
        /// Write CV ops mode by address
        /// </summary>
        Wcvoa = 0xC1, // OPC_WCVOA

        /// <summary>
        /// Cab data (cab signalling)
        /// </summary>
        Cabdat = 0xC2, // OPC_CABDAT

        /// <summary>
        /// Fast clock
        /// </summary>
        Fclk = 0xCF, // OPC_FCLK

        /// <summary>
        /// On event with two data bytes
        /// </summary>
        Acon2 = 0xD0, // OPC_ACON2

        /// <summary>
        /// Off event with two data bytes
        /// </summary>
        Acof2 = 0xD1, // OPC_ACOF2

        /// <summary>
        /// Teach event
        /// </summary>
        Evlrn = 0xd2, // OPC_EVLRN

        /// <summary>
        /// Event variable read response in learn mode
        /// </summary>
        Evans = 0xd3, // OPC_EVANS

        /// <summary>
        /// Accessory on response
        /// </summary>
        Aron2 = 0xD4, // OPC_ARON2

        /// <summary>
        /// Accessory off response
        /// </summary>
        Arof2 = 0xD5, // OPC_AROF2

        /// <summary>
        /// Accessory short on with 2 data bytes
        /// </summary>
        Ason2 = 0xD8, // OPC_ASON2

        /// <summary>
        /// Accessory short off with 2 data bytes
        /// </summary>
        Asof2 = 0xD9, // OPC_ASOF2

        /// <summary>
        /// Short response event on with two data bytes
        /// </summary>
        Arson2 = 0xDD, // OPC_ARSON2

        /// <summary>
        /// Short response event off with two data bytes
        /// </summary>
        Arsof2 = 0xDE, // OPC_ARSOF2

        /// <summary>
        /// Extended opcode with 5 data bytes
        /// </summary>
        Extc5 = 0xDF, // OPC_EXTC5

        /// <summary>
        /// 6 byte DCC packets
        /// </summary>
        Rdcc6 = 0xE0, // OPC_RDCC6

        /// <summary>
        /// Loco session report
        /// </summary>
        Ploc = 0xE1, // OPC_PLOC

        /// <summary>
        /// Module name response
        /// </summary>
        Name = 0xE2, // OPC_NAME

        /// <summary>
        /// Command station status report
        /// </summary>
        Stat = 0xE3, // OPC_STAT

        /// <summary>
        /// CBUS long message packet
        /// </summary>
        Dtxc = 0xE9, // OPC_DTXC

        /// <summary>
        /// Node parameters response
        /// </summary>
        Params = 0xEF, // OPC_PARAMS

        /// <summary>
        /// On event with 3 data bytes
        /// </summary>
        Acon3 = 0xF0, // OPC_ACON3

        /// <summary>
        /// Off event with 3 data bytes
        /// </summary>
        Acof3 = 0xF1, // OPC_ACOF3

        /// <summary>
        /// Read node events response
        /// </summary>
        Enrsp = 0xF2, // OPC_ENRSP

        /// <summary>
        /// Accessory on response
        /// </summary>
        Aron3 = 0xF3, // OPC_ARON3

        /// <summary>
        /// Accessory off response
        /// </summary>
        Arof3 = 0xF4, // OPC_AROF3

        /// <summary>
        /// Teach event using event indexing
        /// </summary>
        Evlrni = 0xF5, // OPC_EVLRNI

        /// <summary>
        /// Accessory data event: 5 bytes of node data (eg: RFID)
        /// </summary>
        Acdat = 0xF6, // OPC_ACDAT

        /// <summary>
        /// Accessory data response
        /// </summary>
        Ardat = 0xF7, // OPC_ARDAT

        /// <summary>
        /// Accessory short on with 3 data bytes
        /// </summary>
        Ason3 = 0xF8, // OPC_ASON3

        /// <summary>
        /// Accessory short off with 3 data bytes
        /// </summary>
        Asof3 = 0xF9, // OPC_ASOF3

        /// <summary>
        /// Short data frame aka device data event (device id plus 5 data bytes)
        /// </summary>
        Ddes = 0xFA, // OPC_DDES

        /// <summary>
        /// Short data frame response aka device data response
        /// </summary>
        Ddrs = 0xFB, // OPC_DDRS

        /// <summary>
        /// Device Data Write Short
        /// </summary>
        Ddws = 0xFC, // OPC_DDWS

        /// <summary>
        /// Short response event on with 3 data bytes
        /// </summary>
        Arson3 = 0xFD, // OPC_ARSON3

        /// <summary>
        /// Short response event off with 3 data bytes
        /// </summary>
        Arsof3 = 0xFE, // OPC_ARSOF3

        /// <summary>
        /// Extended opcode with 6 data byes
        /// </summary>
        Extc6 = 0xFF, // OPC_EXTC6
    }

    /// <summary>
    /// Flags in PAR_FLAGS
    /// </summary>
    public enum ParamFlags
    {

        /// <summary>
        /// Modules doesn't support events
        /// </summary>
        Noevents = 0, // PF_NOEVENTS

        /// <summary>
        /// Module is a consumer of events
        /// </summary>
        Consumer = 1, // PF_CONSUMER

        /// <summary>
        /// Module is a producer of events
        /// </summary>
        Producer = 2, // PF_PRODUCER

        /// <summary>
        /// Module is both a consumer and producer of events
        /// </summary>
        Combi = 3, // PF_COMBI

        /// <summary>
        /// Module is in FLiM mode
        /// </summary>
        Flim = 4, // PF_FLiM

        /// <summary>
        /// Module supports the FCU bootloader protocol
        /// </summary>
        Boot = 8, // PF_BOOT

        /// <summary>
        /// Module can consume its own events
        /// </summary>
        Coe = 16, // PF_COE

        /// <summary>
        /// Module is in learn mode
        /// </summary>
        Lrn = 32, // PF_LRN
    }

    /// <summary>
    /// Offsets to other values stored at the top of the parameter block.
    /// These are not returned by opcode PARAN, but are present in the hex
    /// file for FCU.
    /// </summary>
    public enum ParamOffsetsPic
    {

        /// <summary>
        /// Number of parameters implemented
        /// </summary>
        Count = 0x18, // PAR_COUNT

        /// <summary>
        /// 4 byte Address of Module type name, up to 8 characters null terminated
        /// </summary>
        Name = 0x1A, // PAR_NAME

        /// <summary>
        /// Checksum word at end of parameters
        /// </summary>
        Cksum = 0x1E, // PAR_CKSUM
    }

    /// <summary>
    /// Parameter index numbers (readable by OPC_RQNPN, returned in OPC_PARAN)
    /// Index numbers count from 1, subtract 1 for offset into parameter block
    /// Note that RQNPN with index 0 returns the parameter count
    /// </summary>
    public enum Params
    {

        /// <summary>
        /// Manufacturer id
        /// </summary>
        Manu = 1, // PAR_MANU

        /// <summary>
        /// Minor version letter
        /// </summary>
        Minver = 2, // PAR_MINVER

        /// <summary>
        /// Module type code
        /// </summary>
        Mtyp = 3, // PAR_MTYP

        /// <summary>
        /// Number of events supported
        /// </summary>
        Evtnum = 4, // PAR_EVTNUM

        /// <summary>
        /// Event variables per event
        /// </summary>
        Evnum = 5, // PAR_EVNUM

        /// <summary>
        /// Number of Node variables
        /// </summary>
        Nvnum = 6, // PAR_NVNUM

        /// <summary>
        /// Major version number
        /// </summary>
        Majver = 7, // PAR_MAJVER

        /// <summary>
        /// Node flags
        /// </summary>
        Flags = 8, // PAR_FLAGS

        /// <summary>
        /// Processor type
        /// </summary>
        Cpuid = 9, // PAR_CPUID

        /// <summary>
        /// Bus type
        /// </summary>
        Bustype = 10, // PAR_BUSTYPE

        /// <summary>
        /// load address, 4 bytes
        /// </summary>
        Load = 11, // PAR_LOAD

        /// <summary>
        /// CPU manufacturer's id as read from the chip config space, 4 bytes (note - read from cpu at runtime, so not included in checksum)
        /// </summary>
        Cpumid = 15, // PAR_CPUMID

        /// <summary>
        ///  CPU manufacturer code
        /// </summary>
        Cpuman = 19, // PAR_CPUMAN

        /// <summary>
        /// Beta revision (numeric), or 0 if release
        /// </summary>
        Beta = 20, // PAR_BETA
    }

    /// <summary>
    /// Processor manufacturer codes
    /// </summary>
    public enum ProcessorManufacturers
    {

        Microchip = 1, // CPUM_MICROCHIP

        Atmel = 2, // CPUM_ATMEL

        Arm = 3, // CPUM_ARM
    }

    /// <summary>
    /// Rocrail Module types
    /// </summary>
    public enum RocRailModuleTypes
    {

        /// <summary>
        /// RS232 PC interface
        /// </summary>
        Cangc1 = 1, // MTYP_CANGC1

        /// <summary>
        /// 16 I/O
        /// </summary>
        Cangc2 = 2, // MTYP_CANGC2

        /// <summary>
        /// Command station (derived from cancmd)
        /// </summary>
        Cangc3 = 3, // MTYP_CANGC3

        /// <summary>
        /// 8 channel RFID reader
        /// </summary>
        Cangc4 = 4, // MTYP_CANGC4

        /// <summary>
        /// Cab for fixed panels (derived from cancab)
        /// </summary>
        Cangc5 = 5, // MTYP_CANGC5

        /// <summary>
        /// 4 channel servo controller
        /// </summary>
        Cangc6 = 6, // MTYP_CANGC6

        /// <summary>
        /// Fast clock module
        /// </summary>
        Cangc7 = 7, // MTYP_CANGC7

        /// <summary>
        /// CAN<->Ethernet interface
        /// </summary>
        Cangc1e = 11, // MTYP_CANGC1e
    }

    /// <summary>
    /// Spectrum Engineering Animated Modeller module types
    /// </summary>
    public enum SpectrumModuleTypes
    {

        /// <summary>
        /// Animation controller (firmware derived from cancmd)
        /// </summary>
        Amctrlr = 1, // MTYP_AMCTRLR

        /// <summary>
        /// Dual cab based on cancab
        /// </summary>
        Dualcab = 2, // MTYP_DUALCAB
    }

    /// <summary>
    /// Status codes for OPC_SSTAT
    /// </summary>
    public enum SStats
    {

        NoAck = 1, // SSTAT_NO_ACK

        Ovld = 2, // SSTAT_OVLD

        WrAck = 3, // SSTAT_WR_ACK

        Busy = 4, // SSTAT_BUSY

        CvError = 5, // SSTAT_CV_ERROR
    }

    /// <summary>
    /// Modes for STMOD
    /// </summary>
    public enum StmodModes
    {

        SpdMask = 3, // TMOD_SPD_MASK

        Spd128 = 0, // TMOD_SPD_128

        Spd14 = 1, // TMOD_SPD_14

        Spd28I = 2, // TMOD_SPD_28I

        Spd28 = 3, // TMOD_SPD_28
    }
}
